const std = @import("std");

/// Build-time generator for MNIST embedded test images.
///
/// This is the Zig equivalent of the provided Rust `build.rs`.
///
/// It scans `bin/mnist/test_images/*.bin`, sorts filenames for stable ordering,
/// and writes a Zig source file (default: `bin/mnist/generated/embedded_images.zig`)
/// containing:
///   - `pub const EMBEDDED_TEST_IMAGES: []const []const u8`
///   - `pub const EMBEDDED_TEST_IMAGE_NAMES: []const []const u8`
///   - `pub const EMBEDDED_TEST_IMAGE_COUNT: usize`
///
/// Usage (from the repo root):
///   zig run bin/mnist/build_tools/gen_embedded_images.zig -- \\
///     --input-dir bin/mnist/test_images \\
///     --output bin/mnist/generated/embedded_images.zig
///
/// Notes:
/// - This generator is intended to run on the host during `zig build`.
/// - The output file embeds bytes as Zig array literals (no @embedFile),
///   so the resulting program does not need a filesystem at runtime.
/// - If the input directory doesn't exist, it generates an empty list.
pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    const args = try std.process.argsAlloc(allocator);
    defer std.process.argsFree(allocator, args);

    const opts = try parseArgs(allocator, args);

    const input_dir_path = opts.input_dir;
    const output_path = opts.output_path;

    // Collect *.bin filenames under input_dir_path.
    var bin_files: std.ArrayListUnmanaged([]const u8) = .{};
    defer {
        for (bin_files.items) |name| allocator.free(name);
        bin_files.deinit(allocator);
    }

    collectBinFiles(allocator, input_dir_path, &bin_files) catch |e| switch (e) {
        // Missing directory => generate empty output.
        error.FileNotFound => {},
        error.NotDir => return e,
        else => return e,
    };

    // Sort for stable ordering.
    std.mem.sort([]const u8, bin_files.items, {}, struct {
        fn lessThan(_: void, a: []const u8, b: []const u8) bool {
            return std.mem.lessThan(u8, a, b);
        }
    }.lessThan);

    // Generate Zig source.
    var out_buf: std.ArrayListUnmanaged(u8) = .{};
    defer out_buf.deinit(allocator);

    {
        try out_buf.writer(allocator).writeAll(
            \\// AUTO-GENERATED FILE. DO NOT EDIT.
            \\// Generated by `bin/mnist/build_tools/gen_embedded_images.zig`.
            \\//
            \\// Source directory:
        );
        try out_buf.writer(allocator).writeAll(input_dir_path);
        try out_buf.writer(allocator).writeAll(
            \\
            \\
            \\pub const EMBEDDED_TEST_IMAGES: []const []const u8 = &[_][]const u8{
            \\
        );
    }

    // Emit each image as an inline byte array literal:
    // &[_]u8{ 0x00, 0x01, ... }
    for (bin_files.items) |file_name| {
        const file_path = try std.fs.path.join(allocator, &.{ input_dir_path, file_name });
        defer allocator.free(file_path);

        var file = try std.fs.cwd().openFile(file_path, .{});
        defer file.close();

        const data = try file.readToEndAlloc(allocator, 1024 * 1024 * 16);
        defer allocator.free(data);

        try out_buf.writer(allocator).writeAll("    &[_]u8{\n");
        try writeByteArrayLiteral(out_buf.writer(allocator), data, 16);
        try out_buf.writer(allocator).writeAll("    },\n");
    }

    try out_buf.writer(allocator).writeAll(
        \\};
        \\
        \\pub const EMBEDDED_TEST_IMAGE_NAMES: []const []const u8 = &[_][]const u8{
        \\
    );

    for (bin_files.items) |file_name| {
        // Escape for Zig string literal.
        const escaped = try escapeZigString(allocator, file_name);
        defer allocator.free(escaped);
        try out_buf.writer(allocator).print("    \"{s}\",\n", .{escaped});
    }

    try out_buf.writer(allocator).print(
        "}};\n\npub const EMBEDDED_TEST_IMAGE_COUNT: usize = {d};\n\n",
        .{bin_files.items.len},
    );

    // Write to disk (create parent dirs).
    try ensureParentDir(output_path);
    var out_file = try std.fs.cwd().createFile(output_path, .{ .truncate = true });
    defer out_file.close();
    try out_file.writeAll(out_buf.items);
}

const Options = struct {
    input_dir: []const u8,
    output_path: []const u8,
};

fn parseArgs(_: std.mem.Allocator, args: []const []const u8) !Options {
    // Defaults match repo layout.
    // We deliberately *borrow* argv slices here (no allocation), since args come from
    // `std.process.argsAlloc` and remain valid until `argsFree` in `main`.
    var input_dir: []const u8 = "bin/mnist/test_images";
    var output_path: []const u8 = "bin/mnist/generated/embedded_images.zig";

    var i: usize = 1; // skip argv0
    while (i < args.len) : (i += 1) {
        const a = args[i];
        if (std.mem.eql(u8, a, "--help") or std.mem.eql(u8, a, "-h")) {
            printHelpAndExit();
        } else if (std.mem.eql(u8, a, "--input-dir")) {
            i += 1;
            if (i >= args.len) return error.InvalidArguments;
            input_dir = args[i];
        } else if (std.mem.eql(u8, a, "--output")) {
            i += 1;
            if (i >= args.len) return error.InvalidArguments;
            output_path = args[i];
        } else {
            // Accept positional forms for convenience:
            // gen ... <input_dir> <output_path>
            // Only if not already overridden.
            if (std.mem.eql(u8, input_dir, "bin/mnist/test_images")) {
                input_dir = a;
            } else if (std.mem.eql(u8, output_path, "bin/mnist/embedded_images.zig")) {
                output_path = a;
            } else {
                return error.InvalidArguments;
            }
        }
    }

    return .{ .input_dir = input_dir, .output_path = output_path };
}

fn printHelpAndExit() noreturn {
    std.debug.print(
        \\gen_embedded_images.zig
        \\
        \\Usage:
        \\  zig run bin/mnist/build_tools/gen_embedded_images.zig -- [options]
        \\
        \\Options:
        \\  --input-dir <dir>   Directory containing *.bin test images
        \\                      (default: bin/mnist/test_images)
        \\  --output <file>     Output Zig file path
        \\                      (default: bin/mnist/embedded_images.zig)
        \\  -h, --help          Show this help
        \\
    , .{});
    std.process.exit(0);
}

fn collectBinFiles(
    allocator: std.mem.Allocator,
    input_dir_path: []const u8,
    out_names: *std.ArrayListUnmanaged([]const u8),
) !void {
    var dir = try std.fs.cwd().openDir(input_dir_path, .{ .iterate = true });
    defer dir.close();

    var it = dir.iterate();
    while (try it.next()) |entry| {
        if (entry.kind != .file) continue;
        if (!std.mem.endsWith(u8, entry.name, ".bin")) continue;
        try out_names.append(allocator, try allocator.dupe(u8, entry.name));
    }
}

fn writeByteArrayLiteral(writer: anytype, data: []const u8, bytes_per_line: usize) !void {
    var i: usize = 0;
    while (i < data.len) : (i += bytes_per_line) {
        const end = @min(i + bytes_per_line, data.len);
        try writer.writeAll("        ");
        var j: usize = i;
        while (j < end) : (j += 1) {
            try writer.print("0x{x:0>2}, ", .{data[j]});
        }
        try writer.writeAll("\n");
    }
}

fn ensureParentDir(path: []const u8) !void {
    const parent = std.fs.path.dirname(path) orelse return;
    try std.fs.cwd().makePath(parent);
}

fn escapeZigString(allocator: std.mem.Allocator, s: []const u8) ![]u8 {
    // Minimal escaping: backslash and double quote, plus control chars via \xNN.
    var out: std.ArrayListUnmanaged(u8) = .{};
    defer out.deinit(allocator);

    for (s) |c| {
        switch (c) {
            '\\' => try out.appendSlice(allocator, "\\\\"),
            '"' => try out.appendSlice(allocator, "\\\""),
            '\n' => try out.appendSlice(allocator, "\\n"),
            '\r' => try out.appendSlice(allocator, "\\r"),
            '\t' => try out.appendSlice(allocator, "\\t"),
            else => {
                if (c < 0x20 or c == 0x7f) {
                    try out.writer(allocator).print("\\x{x:0>2}", .{c});
                } else {
                    try out.append(allocator, c);
                }
            },
        }
    }

    return out.toOwnedSlice(allocator);
}
