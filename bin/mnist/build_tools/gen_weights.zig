const std = @import("std");

/// Build-time generator for MNIST weight binaries.
///
/// This tool generates a Zig source file that embeds the following binaries as
/// `[]const u8` byte arrays:
///   - fc1_weight.bin
///   - fc2_weight.bin
///   - fc3_weight.bin
///
/// The layout and parsing semantics are owned by `inference.zig` (it expects
/// scale at bytes[8..12] and weights at bytes[12..]).
///
/// Usage (from repo root):
///   zig run bin/mnist/build_tools/gen_weights.zig -- \
///     --input-dir bin/mnist/binarys \
///     --output    bin/mnist/weights.zig
///
/// Defaults:
///   input-dir: bin/mnist/binarys
///   output:    bin/mnist/generated/weights.zig
///
/// Output exports:
///   pub const FC1_WEIGHT_DATA: []const u8 = &[_]u8{ ... };
///   pub const FC2_WEIGHT_DATA: []const u8 = &[_]u8{ ... };
///   pub const FC3_WEIGHT_DATA: []const u8 = &[_]u8{ ... };
///
/// Notes:
/// - This is intended to run on the host during `zig build`.
/// - It embeds bytes as literals (no @embedFile), so runtime has no filesystem dependency.
/// - If an input file is missing, the generator fails with a clear error.
pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    const args = try std.process.argsAlloc(allocator);
    defer std.process.argsFree(allocator, args);

    const opts = try parseArgs(args);

    const input_dir = opts.input_dir;
    const output_path = opts.output_path;

    const fc1_path = try std.fs.path.join(allocator, &.{ input_dir, "fc1_weight.bin" });
    defer allocator.free(fc1_path);
    const fc2_path = try std.fs.path.join(allocator, &.{ input_dir, "fc2_weight.bin" });
    defer allocator.free(fc2_path);
    const fc3_path = try std.fs.path.join(allocator, &.{ input_dir, "fc3_weight.bin" });
    defer allocator.free(fc3_path);

    const fc1_data = try readWholeFileAlloc(allocator, fc1_path);
    defer allocator.free(fc1_data);
    const fc2_data = try readWholeFileAlloc(allocator, fc2_path);
    defer allocator.free(fc2_data);
    const fc3_data = try readWholeFileAlloc(allocator, fc3_path);
    defer allocator.free(fc3_data);

    var out_buf: std.ArrayListUnmanaged(u8) = .{};
    defer out_buf.deinit(allocator);

    const w = out_buf.writer(allocator);

    try w.writeAll("// AUTO-GENERATED FILE. DO NOT EDIT.\n");
    try w.writeAll("// Generated by `bin/mnist/build_tools/gen_weights.zig`.\n");
    try w.writeAll("//\n");
    try w.print("// Source directory: {s}\n\n", .{input_dir});
    try w.writeAll("pub const FC1_WEIGHT_DATA: []const u8 = &[_]u8{\n");
    try writeByteArrayLiteral(w, fc1_data, 16);
    try w.writeAll("};\n\n");

    try w.writeAll("pub const FC2_WEIGHT_DATA: []const u8 = &[_]u8{\n");
    try writeByteArrayLiteral(w, fc2_data, 16);
    try w.writeAll("};\n\n");

    try w.writeAll("pub const FC3_WEIGHT_DATA: []const u8 = &[_]u8{\n");
    try writeByteArrayLiteral(w, fc3_data, 16);
    try w.writeAll("};\n");

    try ensureParentDir(output_path);
    var out_file = try std.fs.cwd().createFile(output_path, .{ .truncate = true });
    defer out_file.close();
    try out_file.writeAll(out_buf.items);
}

const Options = struct {
    input_dir: []const u8,
    output_path: []const u8,
};

fn parseArgs(args: []const []const u8) !Options {
    // Defaults match the repository layout.
    var input_dir: []const u8 = "bin/mnist/binarys";
    var output_path: []const u8 = "bin/mnist/generated/weights.zig";

    var i: usize = 1; // skip argv0
    while (i < args.len) : (i += 1) {
        const a = args[i];

        if (std.mem.eql(u8, a, "--help") or std.mem.eql(u8, a, "-h")) {
            printHelpAndExit();
        } else if (std.mem.eql(u8, a, "--input-dir")) {
            i += 1;
            if (i >= args.len) return error.InvalidArguments;
            input_dir = args[i];
        } else if (std.mem.eql(u8, a, "--output")) {
            i += 1;
            if (i >= args.len) return error.InvalidArguments;
            output_path = args[i];
        } else {
            // Positional fallbacks:
            //   gen_weights <input_dir> <output_path>
            if (std.mem.eql(u8, input_dir, "bin/mnist/binarys")) {
                input_dir = a;
            } else if (std.mem.eql(u8, output_path, "bin/mnist/weights.zig")) {
                output_path = a;
            } else {
                return error.InvalidArguments;
            }
        }
    }

    return .{ .input_dir = input_dir, .output_path = output_path };
}

fn printHelpAndExit() noreturn {
    std.debug.print(
        "gen_weights.zig\n" ++
            "\n" ++
            "Usage:\n" ++
            "  zig run bin/mnist/build_tools/gen_weights.zig -- [options]\n" ++
            "\n" ++
            "Options:\n" ++
            "  --input-dir <dir>   Directory containing fc{{1,2,3}}_weight.bin\n" ++
            "                      (default: bin/mnist/binarys)\n" ++
            "  --output <file>     Output Zig file path\n" ++
            "                      (default: bin/mnist/generated/weights.zig)\n" ++
            "  -h, --help          Show this help\n" ++
            "\n",
        .{},
    );
    std.process.exit(0);
}

fn ensureParentDir(path: []const u8) !void {
    const parent = std.fs.path.dirname(path) orelse return;
    try std.fs.cwd().makePath(parent);
}

fn readWholeFileAlloc(allocator: std.mem.Allocator, path: []const u8) ![]u8 {
    var file = std.fs.cwd().openFile(path, .{}) catch |e| {
        std.debug.print("Failed to open weight file: {s}\n", .{path});
        return e;
    };
    defer file.close();

    // 64 MiB cap is plenty for these weights; adjust if needed.
    return file.readToEndAlloc(allocator, 64 * 1024 * 1024) catch |e| {
        std.debug.print("Failed to read weight file: {s}\n", .{path});
        return e;
    };
}

fn writeByteArrayLiteral(writer: anytype, data: []const u8, bytes_per_line: usize) !void {
    var i: usize = 0;
    while (i < data.len) : (i += bytes_per_line) {
        const end = @min(i + bytes_per_line, data.len);
        try writer.writeAll("    ");
        var j: usize = i;
        while (j < end) : (j += 1) {
            try writer.print("0x{x:0>2}, ", .{data[j]});
        }
        try writer.writeAll("\n");
    }
}
